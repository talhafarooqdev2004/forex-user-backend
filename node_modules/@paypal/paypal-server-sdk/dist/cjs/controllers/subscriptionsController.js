"use strict";
/**
 * PayPal Server SDKLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionsController = void 0;
var tslib_1 = require("tslib");
var activateSubscriptionRequest_js_1 = require("../models/activateSubscriptionRequest.js");
var billingPlan_js_1 = require("../models/billingPlan.js");
var cancelSubscriptionRequest_js_1 = require("../models/cancelSubscriptionRequest.js");
var captureSubscriptionRequest_js_1 = require("../models/captureSubscriptionRequest.js");
var createSubscriptionRequest_js_1 = require("../models/createSubscriptionRequest.js");
var modifySubscriptionRequest_js_1 = require("../models/modifySubscriptionRequest.js");
var modifySubscriptionResponse_js_1 = require("../models/modifySubscriptionResponse.js");
var patch_js_1 = require("../models/patch.js");
var planCollection_js_1 = require("../models/planCollection.js");
var planRequest_js_1 = require("../models/planRequest.js");
var subscription_js_1 = require("../models/subscription.js");
var subscriptionCollection_js_1 = require("../models/subscriptionCollection.js");
var subscriptionTransactionDetails_js_1 = require("../models/subscriptionTransactionDetails.js");
var suspendSubscription_js_1 = require("../models/suspendSubscription.js");
var transactionsList_js_1 = require("../models/transactionsList.js");
var updatePricingSchemesRequest_js_1 = require("../models/updatePricingSchemesRequest.js");
var schema_js_1 = require("../schema.js");
var baseController_js_1 = require("./baseController.js");
var subscriptionError_js_1 = require("../errors/subscriptionError.js");
var SubscriptionsController = /** @class */ (function (_super) {
    tslib_1.__extends(SubscriptionsController, _super);
    function SubscriptionsController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Creates a plan that defines pricing and billing cycle details for subscriptions.
     *
     * @param prefer            The preferred server response upon successful completion of the
     *                                                request. Value is: return=minimal. The server returns a minimal
     *                                                response to optimize communication between the API caller and the
     *                                                server. A minimal response includes the id, status and HATEOAS
     *                                                links. return=representation. The server returns a complete
     *                                                resource representation, including the current state of the
     *                                                resource.
     * @param paypalRequestId   The server stores keys for 72 hours.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.createBillingPlan = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var prefer = _b.prefer, paypalRequestId = _b.paypalRequestId, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST', '/v1/billing/plans');
                mapped = req.prepareArgs({
                    prefer: [prefer, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    paypalRequestId: [paypalRequestId, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    body: [body, (0, schema_js_1.optional)(planRequest_js_1.planRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.header('Prefer', mapped.prefer);
                req.header('PayPal-Request-Id', mapped.paypalRequestId);
                req.json(mapped.body);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(billingPlan_js_1.billingPlanSchema, requestOptions)];
            });
        });
    };
    /**
     * Lists billing plans.
     *
     * @param prefer         The preferred server response upon successful completion of the request. Value
     *                                  is: return=minimal. The server returns a minimal response to optimize
     *                                  communication between the API caller and the server. A minimal response includes
     *                                  the id, name, description and HATEOAS links. return=representation. The server
     *                                  returns a complete resource representation, including the current state of the
     *                                  resource.
     * @param productId      Filters the response by a Product ID.
     * @param pageSize       The number of items to return in the response.
     * @param page           A non-zero integer which is the start index of the entire list of items to
     *                                  return in the response. The combination of `page=1` and `page_size=20` returns
     *                                  the first 20 items. The combination of `page=2` and `page_size=20` returns the
     *                                  next 20 items.
     * @param totalRequired  Indicates whether to show the total count in the response.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.listBillingPlans = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var prefer = _b.prefer, productId = _b.productId, pageSize = _b.pageSize, page = _b.page, totalRequired = _b.totalRequired;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('GET', '/v1/billing/plans');
                mapped = req.prepareArgs({
                    prefer: [prefer, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    productId: [productId, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    pageSize: [pageSize, (0, schema_js_1.optional)((0, schema_js_1.number)())],
                    page: [page, (0, schema_js_1.optional)((0, schema_js_1.number)())],
                    totalRequired: [totalRequired, (0, schema_js_1.optional)((0, schema_js_1.boolean)())],
                });
                req.header('Prefer', mapped.prefer);
                req.query('product_id', mapped.productId);
                req.query('page_size', mapped.pageSize);
                req.query('page', mapped.page);
                req.query('total_required', mapped.totalRequired);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(planCollection_js_1.planCollectionSchema, requestOptions)];
            });
        });
    };
    /**
     * Shows details for a plan, by ID.
     *
     * @param id The ID of the plan.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.getBillingPlan = function (id, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({ id: [id, (0, schema_js_1.string)()] });
                req.appendTemplatePath(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["/v1/billing/plans/", ""], ["/v1/billing/plans/", ""])), mapped.id);
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(billingPlan_js_1.billingPlanSchema, requestOptions)];
            });
        });
    };
    /**
     * Updates a plan with the `CREATED` or `ACTIVE` status. For an `INACTIVE` plan, you can make only
     * status updates. You can patch these attributes and objects: Attribute or object Operations
     * description replace payment_preferences.auto_bill_outstanding replace taxes.percentage replace
     * payment_preferences.payment_failure_threshold replace payment_preferences.setup_fee replace
     * payment_preferences.setup_fee_failure_action replace name replace
     *
     * @param id           The ID of the plan.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.patchBillingPlan = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('PATCH');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)((0, schema_js_1.array)(patch_js_1.patchSchema))],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject(["/v1/billing/plans/", ""], ["/v1/billing/plans/", ""])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Activates a plan, by ID.
     *
     * @param id The ID of the plan.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.activateBillingPlan = function (id, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({ id: [id, (0, schema_js_1.string)()] });
                req.appendTemplatePath(templateObject_3 || (templateObject_3 = tslib_1.__makeTemplateObject(["/v1/billing/plans/", "/activate"], ["/v1/billing/plans/", "/activate"])), mapped.id);
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Deactivates a plan, by ID.
     *
     * @param id The ID of the plan.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.deactivateBillingPlan = function (id, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({ id: [id, (0, schema_js_1.string)()] });
                req.appendTemplatePath(templateObject_4 || (templateObject_4 = tslib_1.__makeTemplateObject(["/v1/billing/plans/", "/deactivate"], ["/v1/billing/plans/", "/deactivate"])), mapped.id);
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Updates pricing for a plan. For example, you can update a regular billing cycle from $5 per month to
     * $7 per month.
     *
     * @param id           The ID for the plan.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.updateBillingPlanPricingSchemes = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)(updatePricingSchemesRequest_js_1.updatePricingSchemesRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_5 || (templateObject_5 = tslib_1.__makeTemplateObject(["/v1/billing/plans/", "/update-pricing-schemes"], ["/v1/billing/plans/", "/update-pricing-schemes"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Creates a subscription.
     *
     * @param prefer                    The preferred server response upon
     *                                                                      successful completion of the request. Value
     *                                                                      is: return=minimal. The server returns a
     *                                                                      minimal response to optimize communication
     *                                                                      between the API caller and the server. A
     *                                                                      minimal response includes the id, status and
     *                                                                      HATEOAS links. return=representation. The
     *                                                                      server returns a complete resource
     *                                                                      representation, including the current state
     *                                                                      of the resource.
     * @param paypalRequestId           The server stores keys for 72 hours.
     * @param paypalClientMetadataId    The PayPal Client Metadata Id(CMID) is used
     *                                                                      to provide device-specific information to
     *                                                                      PayPal's risk engine. This is crucial for
     *                                                                      transactions that require device-specific
     *                                                                      risk assessments. Merchants typically use the
     *                                                                      Paypal SDK that automatically submits the
     *                                                                      CMID or they use tools like Fraudnet JS for
     *                                                                      web or Magnes JS for mobile to generate the
     *                                                                      CMID on the frontend and then pass it to the
     *                                                                      API as part of the request headers.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.createSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var prefer = _b.prefer, paypalRequestId = _b.paypalRequestId, paypalClientMetadataId = _b.paypalClientMetadataId, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST', '/v1/billing/subscriptions');
                mapped = req.prepareArgs({
                    prefer: [prefer, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    paypalRequestId: [paypalRequestId, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    paypalClientMetadataId: [paypalClientMetadataId, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    body: [body, (0, schema_js_1.optional)(createSubscriptionRequest_js_1.createSubscriptionRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.header('Prefer', mapped.prefer);
                req.header('PayPal-Request-Id', mapped.paypalRequestId);
                req.header('PayPal-Client-Metadata-Id', mapped.paypalClientMetadataId);
                req.json(mapped.body);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(subscription_js_1.subscriptionSchema, requestOptions)];
            });
        });
    };
    /**
     * List all subscriptions for merchant account.
     *
     * @param planIds               Filters the response by list of plan IDs. Filter supports upto 70 plan
     *                                          IDs. URLs should not exceed a length of 2000 characters.
     * @param statuses              Filters the response by list of subscription statuses.
     * @param createdAfter          Filters the response by subscription creation start time for a range of
     *                                          subscriptions.
     * @param createdBefore         Filters the response by subscription creation end time for a range of
     *                                          subscriptions.
     * @param statusUpdatedBefore   Filters the response by status update start time for a range of
     *                                          subscriptions.
     * @param statusUpdatedAfter    Filters the response by status update end time for a range of
     *                                          subscriptions.
     * @param filter                Filter the response using complex expressions that could use comparison
     *                                          operators like ge, gt, le, lt and logical operators such as 'and' and
     *                                          'or'.
     * @param pageSize              The number of items to return in the response.
     * @param page                  A non-zero integer which is the start index of the entire list of items
     *                                          to return in the response. The combination of `page=1` and `page_size=20`
     *                                          returns the first 20 items. The combination of `page=2` and
     *                                          `page_size=20` returns the next 20 items.
     * @param customerIds           Filters the response by comma separated vault customer IDs (FSS
     *                                          subscriptions only).
     * @return Response from the API call
     */
    SubscriptionsController.prototype.listSubscriptions = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var planIds = _b.planIds, statuses = _b.statuses, createdAfter = _b.createdAfter, createdBefore = _b.createdBefore, statusUpdatedBefore = _b.statusUpdatedBefore, statusUpdatedAfter = _b.statusUpdatedAfter, filter = _b.filter, pageSize = _b.pageSize, page = _b.page, customerIds = _b.customerIds;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('GET', '/v1/billing/subscriptions');
                mapped = req.prepareArgs({
                    planIds: [planIds, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    statuses: [statuses, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    createdAfter: [createdAfter, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    createdBefore: [createdBefore, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    statusUpdatedBefore: [statusUpdatedBefore, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    statusUpdatedAfter: [statusUpdatedAfter, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    filter: [filter, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    pageSize: [pageSize, (0, schema_js_1.optional)((0, schema_js_1.number)())],
                    page: [page, (0, schema_js_1.optional)((0, schema_js_1.number)())],
                    customerIds: [customerIds, (0, schema_js_1.optional)((0, schema_js_1.array)((0, schema_js_1.string)()))],
                });
                req.query('plan_ids', mapped.planIds);
                req.query('statuses', mapped.statuses);
                req.query('created_after', mapped.createdAfter);
                req.query('created_before', mapped.createdBefore);
                req.query('status_updated_before', mapped.statusUpdatedBefore);
                req.query('status_updated_after', mapped.statusUpdatedAfter);
                req.query('filter', mapped.filter);
                req.query('page_size', mapped.pageSize);
                req.query('page', mapped.page);
                req.query('customer_ids', mapped.customerIds);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(subscriptionCollection_js_1.subscriptionCollectionSchema, requestOptions)];
            });
        });
    };
    /**
     * Shows details for a subscription, by ID.
     *
     * @param id     The ID of the subscription.
     * @param fields List of fields that are to be returned in the response. Possible value for fields are
     *                         last_failed_payment and plan.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.getSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, fields = _b.fields;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    fields: [fields, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                });
                req.query('fields', mapped.fields);
                req.appendTemplatePath(templateObject_6 || (templateObject_6 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", ""], ["/v1/billing/subscriptions/", ""])), mapped.id);
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(subscription_js_1.subscriptionSchema, requestOptions)];
            });
        });
    };
    /**
     * Updates a subscription which could be in ACTIVE or SUSPENDED status. You can override plan level
     * default attributes by providing customised values for plan path in the patch request. You cannot
     * update attributes that have already completed (Example - trial cycles canâ€™t be updated if completed).
     * Once overridden, changes to plan resource will not impact subscription. Any price update will not
     * impact billing cycles within next 10 days (Applicable only for subscriptions funded by PayPal
     * account). Following are the fields eligible for patch. Attribute or object Operations billing_info.
     * outstanding_balance replace custom_id add,replace plan.billing_cycles[@sequence==n]. pricing_scheme.
     * fixed_price add,replace plan.billing_cycles[@sequence==n]. pricing_scheme.tiers replace plan.
     * billing_cycles[@sequence==n]. total_cycles replace plan.payment_preferences. auto_bill_outstanding
     * replace plan.payment_preferences. payment_failure_threshold replace plan.taxes.inclusive add,replace
     * plan.taxes.percentage add,replace shipping_amount add,replace start_time replace subscriber.
     * shipping_address add,replace subscriber.payment_source (for subscriptions funded by card payments)
     * replace
     *
     * @param id           The ID for the subscription.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.patchSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('PATCH');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)((0, schema_js_1.array)(patch_js_1.patchSchema))],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_7 || (templateObject_7 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", ""], ["/v1/billing/subscriptions/", ""])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Updates the quantity of the product or service in a subscription. You can also use this method to
     * switch the plan and update the `shipping_amount`, `shipping_address` values for the subscription.
     * This type of update requires the buyer's consent.
     *
     * @param id           The ID of the subscription.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.reviseSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)(modifySubscriptionRequest_js_1.modifySubscriptionRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_8 || (templateObject_8 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/revise"], ["/v1/billing/subscriptions/", "/revise"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(modifySubscriptionResponse_js_1.modifySubscriptionResponseSchema, requestOptions)];
            });
        });
    };
    /**
     * Suspends the subscription.
     *
     * @param id           The ID of the subscription.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.suspendSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)(suspendSubscription_js_1.suspendSubscriptionSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_9 || (templateObject_9 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/suspend"], ["/v1/billing/subscriptions/", "/suspend"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Cancels the subscription.
     *
     * @param id           The ID of the subscription.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.cancelSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)(cancelSubscriptionRequest_js_1.cancelSubscriptionRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_10 || (templateObject_10 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/cancel"], ["/v1/billing/subscriptions/", "/cancel"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Activates the subscription.
     *
     * @param id           The ID of the subscription.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.activateSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    body: [body, (0, schema_js_1.optional)(activateSubscriptionRequest_js_1.activateSubscriptionRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_11 || (templateObject_11 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/activate"], ["/v1/billing/subscriptions/", "/activate"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.call(requestOptions)];
            });
        });
    };
    /**
     * Captures an authorized payment from the subscriber on the subscription.
     *
     * @param id                The ID of the subscription.
     * @param paypalRequestId   The server stores keys for 72 hours.
     * @param body
     * @return Response from the API call
     */
    SubscriptionsController.prototype.captureSubscription = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, paypalRequestId = _b.paypalRequestId, body = _b.body;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('POST');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    paypalRequestId: [paypalRequestId, (0, schema_js_1.optional)((0, schema_js_1.string)())],
                    body: [body, (0, schema_js_1.optional)(captureSubscriptionRequest_js_1.captureSubscriptionRequestSchema)],
                });
                req.header('Content-Type', 'application/json');
                req.header('PayPal-Request-Id', mapped.paypalRequestId);
                req.json(mapped.body);
                req.appendTemplatePath(templateObject_12 || (templateObject_12 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/capture"], ["/v1/billing/subscriptions/", "/capture"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(422, subscriptionError_js_1.SubscriptionError, 'The requested action could not be performed, semantically incorrect, or failed business validation.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson((0, schema_js_1.nullable)(subscriptionTransactionDetails_js_1.subscriptionTransactionDetailsSchema), requestOptions)];
            });
        });
    };
    /**
     * Lists transactions for a subscription.
     *
     * @param id         The ID of the subscription.
     * @param startTime  The start time of the range of transactions to list.
     * @param endTime    The end time of the range of transactions to list.
     * @return Response from the API call
     */
    SubscriptionsController.prototype.listSubscriptionTransactions = function (_a, requestOptions_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function (_b, requestOptions) {
            var req, mapped;
            var id = _b.id, startTime = _b.startTime, endTime = _b.endTime;
            return tslib_1.__generator(this, function (_c) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({
                    id: [id, (0, schema_js_1.string)()],
                    startTime: [startTime, (0, schema_js_1.string)()],
                    endTime: [endTime, (0, schema_js_1.string)()],
                });
                req.query('start_time', mapped.startTime);
                req.query('end_time', mapped.endTime);
                req.appendTemplatePath(templateObject_13 || (templateObject_13 = tslib_1.__makeTemplateObject(["/v1/billing/subscriptions/", "/transactions"], ["/v1/billing/subscriptions/", "/transactions"])), mapped.id);
                req.throwOn(400, subscriptionError_js_1.SubscriptionError, 'Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.');
                req.throwOn(401, subscriptionError_js_1.SubscriptionError, 'Authentication failed due to missing authorization header, or invalid authentication credentials.');
                req.throwOn(403, subscriptionError_js_1.SubscriptionError, 'Authorization failed due to insufficient permissions.');
                req.throwOn(404, subscriptionError_js_1.SubscriptionError, 'The specified resource does not exist.');
                req.throwOn(500, subscriptionError_js_1.SubscriptionError, 'An internal server error has occurred.');
                req.defaultToError(subscriptionError_js_1.SubscriptionError, 'The error response.');
                req.authenticate([{ oauth2: true }]);
                return [2 /*return*/, req.callAsJson(transactionsList_js_1.transactionsListSchema, requestOptions)];
            });
        });
    };
    return SubscriptionsController;
}(baseController_js_1.BaseController));
exports.SubscriptionsController = SubscriptionsController;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13;
//# sourceMappingURL=subscriptionsController.js.map